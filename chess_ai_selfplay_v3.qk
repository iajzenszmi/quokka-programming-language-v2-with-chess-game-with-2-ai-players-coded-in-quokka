// chess_ai_selfplay_v2.qk
// Quokka VM friendly: no 'break', '&&', '||', or '!' operators.
// Uses integers 0/1 for booleans; nested ifs instead of boolean ops.

func abs(x) {
  if (x < 0) { return 0 - x; }
  return x;
}

func sign(x) {
  if (x < 0) { return -1; }
  if (x > 0) { return 1; }
  return 0;
}

func idx(f, r) { return r*8 + f; }
func file_of(i) { return i % 8; }
func rank_of(i) { return i / 8; }

func in_bounds(f, r) {
  if (f < 0) { return 0; }
  if (f >= 8) { return 0; }
  if (r < 0) { return 0; }
  if (r >= 8) { return 0; }
  return 1;
}

func fileName(f) {
  if (f == 0) { return "a"; }
  if (f == 1) { return "b"; }
  if (f == 2) { return "c"; }
  if (f == 3) { return "d"; }
  if (f == 4) { return "e"; }
  if (f == 5) { return "f"; }
  if (f == 6) { return "g"; }
  if (f == 7) { return "h"; }
  return "?";
}

func pieceLetter(p) {
  let ap = abs(p);
  if (ap == 0) { return "."; }
  if (ap == 1) { if (p > 0) { return "P"; } else { return "p"; } }
  if (ap == 2) { if (p > 0) { return "N"; } else { return "n"; } }
  if (ap == 3) { if (p > 0) { return "B"; } else { return "b"; } }
  if (ap == 4) { if (p > 0) { return "R"; } else { return "r"; } }
  if (ap == 5) { if (p > 0) { return "Q"; } else { return "q"; } }
  if (p > 0) { return "K"; } else { return "k"; }
}

func startingBoard() {
  let b = array(64);
  b[idx(0,0)] = 4; b[idx(1,0)] = 2; b[idx(2,0)] = 3; b[idx(3,0)] = 5;
  b[idx(4,0)] = 6; b[idx(5,0)] = 3; b[idx(6,0)] = 2; b[idx(7,0)] = 4;
  let f = 0;
  while (f < 8) { b[idx(f,1)] = 1; f = f + 1; }
  b[idx(0,7)] = -4; b[idx(1,7)] = -2; b[idx(2,7)] = -3; b[idx(3,7)] = -5;
  b[idx(4,7)] = -6; b[idx(5,7)] = -3; b[idx(6,7)] = -2; b[idx(7,7)] = -4;
  f = 0;
  while (f < 8) { b[idx(f,6)] = -1; f = f + 1; }
  return b;
}

func boardToString(b) {
  let s = "\n  +------------------------+\n";
  let r = 7;
  while (r >= 0) {
    let line = "";
    let f = 0;
    while (f < 8) {
      let p = b[idx(f,r)];
      line = line + " " + pieceLetter(p);
      f = f + 1;
    }
    s = s + ("" + (r+1)) + " |" + line + " |\n";
    r = r - 1;
  }
  s = s + "  +------------------------+\n";
  s = s + "    a b c d e f g h\n";
  return s;
}

func coord(i) {
  let f = file_of(i);
  let r = rank_of(i);
  return fileName(f) + ("" + (r+1));
}

func rand(r) {
  let x = r[0];
  x = (x * 1664525 + 1013904223) % 2147483647;
  if (x < 0) { x = 0 - x; }
  r[0] = x;
  return x;
}

func randn(r, n) {
  let x = rand(r);
  if (n <= 0) { return 0; }
  return x % n;
}

func pathClear(b, f0, r0, f1, r1) {
  let df = f1 - f0;
  let dr = r1 - r0;
  let sf = sign(df);
  let sr = sign(dr);
  let steps = df; if (abs(dr) > abs(df)) { steps = dr; }
  steps = abs(steps);
  let k = 1;
  while (k < steps) {
    let ff = f0 + sf*k;
    let rr = r0 + sr*k;
    if (b[idx(ff,rr)] != 0) { return 0; }
    k = k + 1;
  }
  return 1;
}

func addMove(moves, mc, from, to) {
  let m = mc[0];
  if (m < len(moves)) {
    moves[m] = from*64 + to;
    mc[0] = m + 1;
  }
}

// --- Pawn moves without && ---
func addPawnMoves(b, moves, mc, i, white) {
  let f0 = file_of(i);
  let r0 = rank_of(i);
  if (white == 1) {
    // forward 1
    if (in_bounds(f0, r0+1) == 1) {
      if (b[idx(f0,r0+1)] == 0) { addMove(moves, mc, i, idx(f0,r0+1)); }
    }
    // forward 2 from rank 1
    if (r0 == 1) {
      if (b[idx(f0,r0+1)] == 0) {
        if (b[idx(f0,r0+2)] == 0) {
          addMove(moves, mc, i, idx(f0,r0+2));
        }
      }
    }
    // captures
    if (in_bounds(f0+1, r0+1) == 1) {
      if (b[idx(f0+1,r0+1)] < 0) { addMove(moves, mc, i, idx(f0+1,r0+1)); }
    }
    if (in_bounds(f0-1, r0+1) == 1) {
      if (b[idx(f0-1,r0+1)] < 0) { addMove(moves, mc, i, idx(f0-1,r0+1)); }
    }
  } else {
    if (in_bounds(f0, r0-1) == 1) {
      if (b[idx(f0,r0-1)] == 0) { addMove(moves, mc, i, idx(f0,r0-1)); }
    }
    if (r0 == 6) {
      if (b[idx(f0,r0-1)] == 0) {
        if (b[idx(f0,r0-2)] == 0) {
          addMove(moves, mc, i, idx(f0,r0-2));
        }
      }
    }
    if (in_bounds(f0+1, r0-1) == 1) {
      if (b[idx(f0+1,r0-1)] > 0) { addMove(moves, mc, i, idx(f0+1,r0-1)); }
    }
    if (in_bounds(f0-1, r0-1) == 1) {
      if (b[idx(f0-1,r0-1)] > 0) { addMove(moves, mc, i, idx(f0-1,r0-1)); }
    }
  }
}

func addKnightMoves(b, moves, mc, i, white) {
  let f0 = file_of(i);
  let r0 = rank_of(i);
  let df = array(8); df[0]=1; df[1]=2; df[2]=2; df[3]=1; df[4]=-1; df[5]=-2; df[6]=-2; df[7]=-1;
  let dr = array(8); dr[0]=2; dr[1]=1; dr[2]=-1; dr[3]=-2; dr[4]=-2; dr[5]=-1; dr[6]=1; dr[7]=2;
  let t = 0;
  while (t < 8) {
    let f1 = f0 + df[t];
    let r1 = r0 + dr[t];
    if (in_bounds(f1,r1) == 1) {
      let p = b[idx(f1,r1)];
      if (white == 1) {
        if (p <= 0) { addMove(moves, mc, i, idx(f1,r1)); }
      } else {
        if (p >= 0) { addMove(moves, mc, i, idx(f1,r1)); }
      }
    }
    t = t + 1;
  }
}

// --- Slider without break ---
func addSlider(b, moves, mc, i, white, stepF, stepR) {
  let f0 = file_of(i);
  let r0 = rank_of(i);
  let f1 = f0 + stepF;
  let r1 = r0 + stepR;
  let cont = 1;
  while (cont == 1) {
    if (in_bounds(f1,r1) == 0) {
      cont = 0;
    } else {
      let p = b[idx(f1,r1)];
      if (p == 0) {
        addMove(moves, mc, i, idx(f1,r1));
        f1 = f1 + stepF;
        r1 = r1 + stepR;
      } else {
        if (white == 1) {
          if (p < 0) { addMove(moves, mc, i, idx(f1,r1)); }
        } else {
          if (p > 0) { addMove(moves, mc, i, idx(f1,r1)); }
        }
        cont = 0;
      }
    }
  }
}

func addBishopMoves(b, moves, mc, i, white) {
  addSlider(b, moves, mc, i, white, 1, 1);
  addSlider(b, moves, mc, i, white, 1, -1);
  addSlider(b, moves, mc, i, white, -1, 1);
  addSlider(b, moves, mc, i, white, -1, -1);
}

func addRookMoves(b, moves, mc, i, white) {
  addSlider(b, moves, mc, i, white, 1, 0);
  addSlider(b, moves, mc, i, white, -1, 0);
  addSlider(b, moves, mc, i, white, 0, 1);
  addSlider(b, moves, mc, i, white, 0, -1);
}

func addQueenMoves(b, moves, mc, i, white) {
  addBishopMoves(b, moves, mc, i, white);
  addRookMoves(b, moves, mc, i, white);
}

func addKingMoves(b, moves, mc, i, white) {
  let df = -1;
  while (df <= 1) {
    let dr = -1;
    while (dr <= 1) {
      if ((df == 0) && (dr == 0)) {
        // skip origin
      } else {
        let f1 = file_of(i) + df;
        let r1 = rank_of(i) + dr;
        if (in_bounds(f1,r1) == 1) {
          let p = b[idx(f1,r1)];
          if (white == 1) {
            if (p <= 0) { addMove(moves, mc, i, idx(f1,r1)); }
          } else {
            if (p >= 0) { addMove(moves, mc, i, idx(f1,r1)); }
          }
        }
      }
      dr = dr + 1;
    }
    df = df + 1;
  }
}

func genAllMoves(b, white, moves, mc) {
  mc[0] = 0;
  let i = 0;
  while (i < 64) {
    let p = b[i];
    if (p != 0) {
      if (white == 1) {
        if (p > 0) {
                    let ap = abs(p);
          if (ap == 1) { addPawnMoves(b, moves, mc, i, white); }
          else {
            if (ap == 2) { addKnightMoves(b, moves, mc, i, white); }
            else {
              if (ap == 3) { addBishopMoves(b, moves, mc, i, white); }
              else {
                if (ap == 4) { addRookMoves(b, moves, mc, i, white); }
                else {
                  if (ap == 5) { addQueenMoves(b, moves, mc, i, white); }
                  else { addKingMoves(b, moves, mc, i, white); }
                }
              }
            }
          }
        }
      } else {
        if (p < 0) {
                    let ap = abs(p);
          if (ap == 1) { addPawnMoves(b, moves, mc, i, white); }
          else {
            if (ap == 2) { addKnightMoves(b, moves, mc, i, white); }
            else {
              if (ap == 3) { addBishopMoves(b, moves, mc, i, white); }
              else {
                if (ap == 4) { addRookMoves(b, moves, mc, i, white); }
                else {
                  if (ap == 5) { addQueenMoves(b, moves, mc, i, white); }
                  else { addKingMoves(b, moves, mc, i, white); }
                }
              }
            }
          }
        }
      }
    }
    i = i + 1;
  }
}

func makeMove(b, from, to) {
  let p = b[from];
  b[to] = p;
  b[from] = 0;
  let r = rank_of(to);
  if ((p == 1) && (r == 7)) { b[to] = 5; }
  if ((p == -1) && (r == 0)) { b[to] = -5; }
}

func findKing(b, white) {
  let target = 6;
  if (white == 0) { target = -6; }
  let i = 0;
  while (i < 64) {
    if (b[i] == target) { return i; }
    i = i + 1;
  }
  return -1;
}

func moveStr(m) {
  let from = m / 64;
  let to = m % 64;
  return coord(from) + coord(to);
}

func main() {
  let b = startingBoard();
  let rng = array(1); rng[0] = 1234567;
  let moves = array(512);
  let mc = array(1); mc[0] = 0;

  print "Quokka Chess (AI vs AI, no castling/en passant, promotion=Q)";
  print boardToString(b);

  let white = 1;
  let ply = 0;
  let running = 1;

  while (running == 1) {
    genAllMoves(b, white, moves, mc);
    let count = mc[0];
    if (count == 0) {
      if (white == 1) { print "White has no moves. Game over."; }
      else { print "Black has no moves. Game over."; }
      running = 0;
    }

    if (running == 1) {
      let kpos = findKing(b, 1);
      if (kpos < 0) { print "White king captured. Black wins."; running = 0; }
    }
    if (running == 1) {
      let kpos2 = findKing(b, 0);
      if (kpos2 < 0) { print "Black king captured. White wins."; running = 0; }
    }

    if (running == 1) {
      let pick = randn(rng, count);
      let mv = moves[pick];
      let from = mv / 64;
      let to = mv % 64;

      let mover = "White";
      if (white == 0) { mover = "Black"; }

      print (mover + ": " + moveStr(mv));
      makeMove(b, from, to);
      print boardToString(b);

      white = 1 - white;
      ply = ply + 1;
      if (ply >= 300) {
        print "Reached move limit. Draw.";
        running = 0;
      }
    }
  }
  return 0;
}